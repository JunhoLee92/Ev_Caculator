import math

#############################
# 1) 파라미터 / 가격표 설정
#############################

# --- 기본 파라미터 ---
BASE_ITEM_PRICE = 18000   # 아이템 기본 구매 비용
MAX_TRIES       = 7       # 최대 강화 시도 횟수

# --- 10% 주문서 ---
p10      = 0.10  # 성공 확률
up10     = 5     # 공격력 증가치 (성공 시)
cost10   = 0     # 10% 주문서 사용 비용(필요 시 추가)

# --- 60% 주문서 ---
p60      = 0.60
up60     = 2
cost60   = 0     # 60% 주문서 사용 비용(필요 시 추가)

# --- 70% 주문서 ---
p70_success = 0.70
p70_keep    = 0.15   # 실패해도 유지
p70_destroy = 0.15   # 실패 시 파괴
cost70      = 4000   # 70% 주문서 사용 비용

# ------------------------------------------------------------------
# 공격력 최대치(+17),
# 파괴 상태(18)로 정의
# ------------------------------------------------------------------
ATK_MAX         = 17
DESTROYED_STATE = 18

# --- 공격력별 판매가격표 ---
#   +0~+5 : 0원
#   +6  : 2400
#   +7  : 5000
#   +8  : 7000
#   +9  : 9000
#   +10 : 17000
#   +11 : 23000
#   +12 : 50000
#   +13 : 100000
#   +14 : 180000
#   +15 : 300000
#   +16 : 500000
#   +17 : 500000  (사용자 요청: +16과 동일한 가격)
#   18  : 파괴 상태 => 0원
prices = {
    0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0,
    6: 2400, 7: 5000, 8: 7000, 9: 9000,
    10: 17000, 11: 23000, 12: 50000,
    13: 100000, 14: 180000, 15: 300000,
    16: 500000, 17: 700000,
    18: 0  # 파괴
}


#############################
# 2) DP 테이블(E)와 정책(P) 초기화
#############################
# E[i][a] : 남은 강화 시도 횟수가 i번, 현재 공격력이 a일 때의 최대 기대값
# P[i][a] : 그 때 최적의 선택(어느 스크롤을 쓰는지 혹은 강화 중단)

# ATK_MAX = 17, DESTROYED_STATE = 18 이므로,
# 공격력 인덱스는 0..17(18개) + 파괴상태(1개) = 총 19개.
E = [[0] * (ATK_MAX + 2) for _ in range(MAX_TRIES + 1)]  # (ATK_MAX+2) = 19
P = [[""] * (ATK_MAX + 2) for _ in range(MAX_TRIES + 1)]


#############################
# 3) 기저 조건 설정 (i = MAX_TRIES)
#############################
# 강화 시도 횟수를 모두 소진(i=MAX_TRIES)하면 더이상 강화 불가
# => 그때는 아이템을 판매한다고 가정하고,
#    판매 가격 - 아이템 기본 비용을 기대값으로 본다.
for a in range(ATK_MAX + 2):  # 0..18
    if a == DESTROYED_STATE:
        # 파괴 상태이면 판매 불가 -> 수익 0원
        E[MAX_TRIES][a] = -BASE_ITEM_PRICE
    else:
        # a 공격력 아이템을 팔 때
        E[MAX_TRIES][a] = prices[a] - BASE_ITEM_PRICE

    P[MAX_TRIES][a] = "End"


#############################
# 4) DP 역순 계산 (i = MAX_TRIES-1 down to 0)
#############################
for i in reversed(range(MAX_TRIES)):
    for a in range(ATK_MAX + 2):
        # 이미 파괴된 상태(=18) => 강화 불가
        if a == DESTROYED_STATE:
            E[i][a] = -BASE_ITEM_PRICE
            P[i][a] = "Destroyed"
            continue

        # -------------------------
        # 1) 60% 스크롤
        # -------------------------
        next_a_60 = min(a + up60, ATK_MAX)  # 공격력 +2 (최대 17)
        EV_60 = (
            -cost60
            + p60 * E[i+1][next_a_60]
            + (1 - p60) * E[i+1][a]
        )

        # -------------------------
        # 2) 10% 스크롤
        # -------------------------
        next_a_10 = min(a + up10, ATK_MAX)  # 공격력 +5 (최대 17)
        EV_10 = (
            -cost10
            + p10 * E[i+1][next_a_10]
            + (1 - p10) * E[i+1][a]
        )

        # -------------------------
        # 3) 70% 스크롤
        # -------------------------
        # - cost70 은 스크롤 사용 비용
        # 성공하면 +2
        # 실패(keep)면 유지
        # 실패(destroy)면 파괴(=18)
        next_a_70 = min(a + up60, ATK_MAX)  # 70% 성공 시 +2
        EV_70 = (
            -cost70
            + p70_success * E[i+1][next_a_70]
            + p70_keep    * E[i+1][a]
            + p70_destroy * E[i+1][DESTROYED_STATE]
        )

        # -------------------------
        # 4) 강화 중단(End)
        # -------------------------
        EV_end = prices[a] - BASE_ITEM_PRICE

        # ----------------------------------------------------
        # 5) 위 4가지 중 최대 기대값을 주는 선택
        # ----------------------------------------------------
        bestEV     = EV_60
        bestChoice = "60%"

        if EV_10 > bestEV:
            bestEV     = EV_10
            bestChoice = "10%"

        if EV_70 > bestEV:
            bestEV     = EV_70
            bestChoice = "70%"

        if EV_end > bestEV:
            bestEV     = EV_end
            bestChoice = "End"

        E[i][a] = bestEV
        P[i][a] = bestChoice


#############################
# 5) 결과 확인
#############################

# 5.1) 초기 상태(i=0, 공격력=0)의 기대값 및 정책
print("초기 상태 (공격력=0, 남은시도=7)에서의 최대 기대값: {:.1f} 원".format(E[0][0]))
print("초기 상태에서의 최적 선택: {}\n".format(P[0][0]))

# 5.2) 특정 상황 조회용 함수
def lookup_policy(i, a):
    """남은 시도 횟수가 i, 현재 공격력이 a일 때의 정책과 기대값을 보여줍니다."""
    if not (0 <= i <= MAX_TRIES):
        return f"[에러] i={i} (0~{MAX_TRIES} 범위를 벗어남)"
    if not (0 <= a <= DESTROYED_STATE):
        return f"[에러] a={a} (0~{DESTROYED_STATE} 범위를 벗어남, {DESTROYED_STATE}=파괴)"
    return f"[i={i}, a={a}] => 선택={P[i][a]}, 기대값={E[i][a]:.1f}"

# 예시 출력
print(lookup_policy(1, 2))  # 남은 시도 0, 공격력+17
print(lookup_policy(7, 0))   # 남은 시도 0, 공격력+0
print(lookup_policy(1, 16))  # 남은 시도 1, 공격력+16
print(lookup_policy(1, 17))  # 남은 시도 1, 공격력+17 (최대 강화)
print(lookup_policy(0, 0))   # 맨 처음 상태
